{-# LANGUAGE OverloadedStrings #-}

module Brite.Syntax.ParserSpec (spec) where

import Brite.Diagnostics
import qualified Brite.Semantics.AST as AST
import qualified Brite.Semantics.ASTDebug as AST
import qualified Brite.Syntax.CST as CST
import Brite.Syntax.Parser
import Brite.Syntax.ParserFramework
import Brite.Syntax.Tokens
import qualified Data.Text (Text)
import qualified Data.Text as Text
import qualified Data.Text.Lazy as Text.Lazy
import qualified Data.Text.Lazy.Builder as Text.Builder
import System.IO
import Test.Hspec

testData :: [T.Text]
testData =
  [ "let x = y;"
  , "let x = y"
  , "let"
  , "let x"
  , "let ="
  , "let y"
  , "let ;"
  , "let x ="
  , "let x y"
  , "let x ;"
  , "let = y"
  , "let = ;"
  , "ğŸ˜ˆ let x = y;"
  , "let ğŸ˜ˆ x = y;"
  , "let x ğŸ˜ˆ = y;"
  , "let x = ğŸ˜ˆ y;"
  , "let x = y ğŸ˜ˆ;"
  , "let x = y; ğŸ˜ˆ"
  , "let x = y ğŸ˜ˆ"
  , ") let x = y;"
  , "let ) x = y;"
  , "let x ) = y;"
  , "let x = ) y;"
  , "let x = y );"
  , "let x = y; )"
  , "let x = y )"
  , "let ğŸ˜ˆ = y;"
  , "let x ğŸ˜ˆ y;"
  , "let x = ğŸ˜ˆ;"
  , "let ğŸ˜ˆ y;"
  , "let ğŸ˜ˆ =;"
  , "let x ğŸ˜ˆ;"
  , "let = ğŸ˜ˆ;"
  , "let ğŸ˜ˆ;"
  , "let ) = y;"
  , "let x ) y;"
  , "let x = );"
  , "let ) y;"
  , "let ) =;"
  , "let x );"
  , "let = );"
  , "let );"
  , "x"
  , "x;"
  , "ğŸ˜ˆ x"
  , "x ğŸ˜ˆ"
  , "ğŸ˜ˆ x;"
  , "x ğŸ˜ˆ;"
  , "x; ğŸ˜ˆ"
  , "="
  , "ğŸ˜ˆ"
  , ")"
  , ";"
  , "true"
  , "false"
  , "true true"
  , "("
  , "(x"
  , "()"
  , "(x)"
  , "x)"
  , "(x;"
  , "let x = (y);"
  , "let x = (y;"
  , "let x = y; let x = y;"
  , "let x = y; let x = y; let x = y;"
  , "let x = y; let x = y; let x = y; let x = y;"
  , "let x = y let x = y"
  , "let x = y let x = y let x = y"
  , "let x = y let x = y let x = y let x = y"
  , "let x = y\nlet x = y"
  , "let x = y\nlet x = y\nlet x = y"
  , "let x = y\nlet x = y\nlet x = y\nlet x = y"
  , "ğŸ˜ˆ let x = y; let x = y; let x = y;"
  , "let x = y; ğŸ˜ˆ let x = y; let x = y;"
  , "let x = y; let x = y; ğŸ˜ˆ let x = y;"
  , "let x = y; let x = y; let x = y; ğŸ˜ˆ"
  , "ğŸ˜ˆ let x = y let x = y let x = y"
  , "let x = y ğŸ˜ˆ let x = y let x = y"
  , "let x = y let x = y ğŸ˜ˆ let x = y"
  , "let x = y let x = y let x = y ğŸ˜ˆ"
  , ") let x = y; let x = y; let x = y;"
  , "let x = y; ) let x = y; let x = y;"
  , "let x = y; let x = y; ) let x = y;"
  , "let x = y; let x = y; let x = y; )"
  , ") let x = y let x = y let x = y"
  , "let x = y ) let x = y let x = y"
  , "let x = y let x = y ) let x = y"
  , "let x = y let x = y let x = y )"
  , "do {}"
  , "do { "
  , "do }"
  , "do } do }"
  , "do"
  , "do do"
  , "do { let x = y; }"
  , "do { let x = y; "
  , "do let x = y; }"
  , "do let x = y }"
  , "do let x = y;"
  , "do let x = y"
  , "let x = (do {);"
  , "let x = (do { let y = z; );"
  , "let x = (do);"
  , "let x = (do let y = z; );"
  , "let x = (do { let y = z );"
  , "let x = (do { let y = );"
  , "do { let x = y; }"
  , "do { let x = y }"
  , "do { let x = y; let x = y; }"
  , "do { let x = y; let x = y; let x = y; }"
  , "do { let x = y; let x = y; let x = y; let x = y; }"
  , "do { let x = y let x = y }"
  , "do { let x = y let x = y let x = y }"
  , "do { let x = y let x = y let x = y let x = y }"
  , "do { let x = y\nlet x = y\n }"
  , "do { let x = y\nlet x = y\nlet x = y\n }"
  , "do { let x = y\nlet x = y\nlet x = y\nlet x = y\n }"
  , "do { ğŸ˜ˆ let x = y; let x = y; let x = y; }"
  , "do { let x = y; ğŸ˜ˆ let x = y; let x = y; }"
  , "do { let x = y; let x = y; ğŸ˜ˆ let x = y; }"
  , "do { let x = y; let x = y; let x = y; ğŸ˜ˆ }"
  , "do { ğŸ˜ˆ let x = y let x = y let x = y }"
  , "do { let x = y ğŸ˜ˆ let x = y let x = y }"
  , "do { let x = y let x = y ğŸ˜ˆ let x = y }"
  , "do { let x = y let x = y let x = y ğŸ˜ˆ }"
  , "do { ) let x = y; let x = y; let x = y; }"
  , "do { let x = y; ) let x = y; let x = y; }"
  , "do { let x = y; let x = y; ) let x = y; }"
  , "do { let x = y; let x = y; let x = y; ) }"
  , "do { ) let x = y let x = y let x = y }"
  , "do { let x = y ) let x = y let x = y }"
  , "do { let x = y let x = y ) let x = y }"
  , "do { let x = y let x = y let x = y ) }"
  , "let x = ) let x = )"
  , "let x = ) )"
  , ") let x = )"
  , "let x = ) ) let x = )"
  , "do do ğŸ˜ˆ"
  , "do do )"
  , "if x {}"
  , "if x { y }"
  , "if x {} else {}"
  , "if x { y } else {}"
  , "if x {} else { y }"
  , "if x { y } else { z }"
  , "if { let x = y }"
  , "if {}"
  , "if x }"
  , "if x {"
  , "if x"
  , "if {"
  , "if }"
  , "if {} else {}"
  , "if x } else {}"
  , "if x { else {}"
  , "if x else {}"
  , "if { else {}"
  , "if } else {}"
  , "if {} {}"
  , "if x } {}"
  , "if x { {}"
  , "if { {}"
  , "if } {}"
  , "if {} else }"
  , "if x } else }"
  , "if x { else }"
  , "if x else }"
  , "if { else }"
  , "if } else }"
  , "if {} else {"
  , "if x } else {"
  , "if x { else {"
  , "if x else {"
  , "if { else {"
  , "if } else {"
  , "if {} else"
  , "if x } else"
  , "if x { else"
  , "if x else"
  , "if { else"
  , "if } else"
  , "if {} {"
  , "if x } {"
  , "if x { {"
  , "if x {"
  , "if { {"
  , "if } {"
  , "if {} }"
  , "if x } }"
  , "if x { }"
  , "if x }"
  , "if { }"
  , "if } }"
  , "x ğŸ˜ˆ ğŸ˜ˆ ;"
  , "x ) ) ;"
  , "let ğŸ˜ˆ ğŸ˜ˆ x = y;"
  , "let ) ) x = y;"
  , "ğŸ˜ˆ ğŸ˜ˆ"
  , ") )"
  , "if x {} { let y = z }"
  , "o.p"
  , "o.p.q"
  , "o."
  , "o.p."
  , "o..p"
  , "o p"
  , "oğŸ˜ˆ.p"
  , "o.ğŸ˜ˆp"
  , "o.ğŸ˜ˆp.q"
  , "o.pğŸ˜ˆ.q"
  , "o.p.ğŸ˜ˆq"
  , "o).p"
  , "o.)p"
  , "o.)p.q"
  , "o.p).q"
  , "o.p.)q"
  , "if x {} ğŸ˜ˆ"
  , "if x {} ğŸ˜ˆ else {}"
  , "if x {} )"
  , "if x {} ) else {}"
  , "if ğŸ˜ˆ x {}"
  , "if x ğŸ˜ˆ {}"
  , "if ) x {}"
  , "if x ) {}"
  , "do {}.p"
  , "if x {}.p"
  , "if x {} else {}.p"
  , "f()"
  , "f ()"
  , "fğŸ˜ˆ()"
  , "f)()"
  , "f\n()"
  , "f;()"
  , "f\nğŸ˜ˆ()"
  , "fğŸ˜ˆ\n()"
  , "f\n)()"
  , "f)\n()"
  , "f(ğŸ˜ˆ)"
  , "f("
  , "ğŸ˜ˆ.p"
  , "(ğŸ˜ˆ.p)"
  , "let ğŸ˜ˆ) = y;"
  , "let )ğŸ˜ˆ = y;"
  , "let ğŸ˜ˆ)x = y;"
  , "let )ğŸ˜ˆx = y;"
  , "let x = y ğŸ˜ˆ);"
  , "let x = y )ğŸ˜ˆ;"
  , ")ğŸ˜ˆ let x = y;"
  , "ğŸ˜ˆ) let x = y;"
  , "let x = y; )ğŸ˜ˆ"
  , "let x = y; ğŸ˜ˆ)"
  , ")ğŸ˜ˆ"
  , "ğŸ˜ˆ)"
  , "let x = ğŸ¶ğŸ± y;"
  , "if x {} ğŸ¶ğŸ± else {}"
  , "if x {} ğŸ¶ğŸ± else {"
  , "let x = y; do { let x = y; ğŸ˜ˆ let x = y; } let x = y;"
  , "let x = ğŸ˜ˆ let x = y"
  , "f(x)"
  , "f\n(x)"
  , "f;(x)"
  , "f(a)"
  , "f(ağŸ˜ˆ)"
  , "f(a})"
  , "f(ağŸ˜ˆ})"
  , "f(a}ğŸ˜ˆ)"
  , "f(ağŸ˜ˆ,)"
  , "f(a},)"
  , "f(ağŸ˜ˆ},)"
  , "f(a}ğŸ˜ˆ,)"
  , "f(ağŸ˜ˆ, b)"
  , "f(a}, b)"
  , "f(ağŸ˜ˆ}, b)"
  , "f(a}ğŸ˜ˆ, b)"
  , "f(ağŸ˜ˆ, b.)" -- NOTE: `b.` is used here and below to enter â€œyieldâ€ mode for the expression.
  , "f(a}, b.)"
  , "f(ağŸ˜ˆ}, b.)"
  , "f(a}ğŸ˜ˆ, b.)"
  , "f(ağŸ˜ˆ b)"
  , "f(a} b)"
  , "f(ağŸ˜ˆ} b)"
  , "f(a}ğŸ˜ˆ b)"
  , "f(ağŸ˜ˆ b.)"
  , "f(a} b.)"
  , "f(ağŸ˜ˆ} b.)"
  , "f(a}ğŸ˜ˆ b.)"
  , "f(a, b)"
  , "f(a, bğŸ˜ˆ)"
  , "f(a, b})"
  , "f(a, b}ğŸ˜ˆ)"
  , "f(a, bğŸ˜ˆ})"
  , "f(a, bğŸ˜ˆ,)"
  , "f(a, b},)"
  , "f(a, b}ğŸ˜ˆ,)"
  , "f(a, bğŸ˜ˆ},)"
  , "f(a, bğŸ˜ˆ, c)"
  , "f(a, b}, c)"
  , "f(a, b}ğŸ˜ˆ, c)"
  , "f(a, bğŸ˜ˆ}, c)"
  , "f(a, bğŸ˜ˆ, c.)"
  , "f(a, b}, c.)"
  , "f(a, b}ğŸ˜ˆ, c.)"
  , "f(a, bğŸ˜ˆ}, c.)"
  , "f(a, bğŸ˜ˆ c)"
  , "f(a, b} c)"
  , "f(a, b}ğŸ˜ˆ c)"
  , "f(a, bğŸ˜ˆ} c)"
  , "f(a, bğŸ˜ˆ c.)"
  , "f(a, b} c.)"
  , "f(a, b}ğŸ˜ˆ c.)"
  , "f(a, bğŸ˜ˆ} c.)"
  , "f(a.)"
  , "f(a.,)"
  , "f(a., b)"
  , "f(a. (b))"
  , "f(a. (b).)"
  , "f(a.ğŸ˜ˆ)"
  , "f(a.})"
  , "f(a.ğŸ˜ˆ})"
  , "f(a.}ğŸ˜ˆ)"
  , "f(a, b.)"
  , "f(a, b.,)"
  , "f(a, b., c)"
  , "f(a, b. (c))"
  , "f(a, b. (c).)"
  , "f(a, b.ğŸ˜ˆ)"
  , "f(a, b.})"
  , "f(a, b.ğŸ˜ˆ})"
  , "f(a, b.}ğŸ˜ˆ)"
  , "f(ğŸ˜ˆ)"
  , "f(})"
  , "f(ğŸ˜ˆ})"
  , "f(}ğŸ˜ˆ)"
  , "f(a, ğŸ˜ˆ)"
  , "f(a, })"
  , "f(a, ğŸ˜ˆ})"
  , "f(a, }ğŸ˜ˆ)"
  , "f(a b)"
  , "f(a, b c)"
  , "f(a b, c)"
  , "f(a b c)"
  , "f(a b, c, d)"
  , "f(a, b c, d)"
  , "f(a, b, c d)"
  , "f(a b c, d)"
  , "f(a, b c d)"
  , "f(a b, c d)"
  , "f(a b c d)"
  , "f(a,, b)"
  , "f(a,, b, c)"
  , "f(a, b,, c)"
  , "f(a,, b,, c)"
  , "f(a,, b, c, d)"
  , "f(a, b,, c, d)"
  , "f(a, b, c,, d)"
  , "f(a, b,, c,, d)"
  , "f(a,, b, c,, d)"
  , "f(a,, b,, c, d)"
  , "f(a,, b,, c,, d)"
  , "f(a, b, c, d,)"
  , "f(a, b, c, d,,)"
  , "f(a, b, c,,)"
  , "f(a, b,,)"
  , "f(a,,)"
  , "f(a, ğŸ˜ˆ, c)"
  , "f(ğŸ˜ˆ, b, c)"
  , "f(a, b, ğŸ˜ˆ)"
  , "f(a, }, c)"
  , "f(}, b, c)"
  , "f(a, b, })"
  , "f(a, ğŸ˜ˆ}, c)"
  , "f(ğŸ˜ˆ}, b, c)"
  , "f(a, b, ğŸ˜ˆ})"
  , "f(a, }ğŸ˜ˆ, c)"
  , "f(}ğŸ˜ˆ, b, c)"
  , "f(a, b, }ğŸ˜ˆ)"
  , "f(a, bğŸ˜ˆ, c)"
  , "f(ağŸ˜ˆ, b, c)"
  , "f(a, b, cğŸ˜ˆ)"
  , "f(a, b}, c)"
  , "f(a}, b, c)"
  , "f(a, b, c})"
  , "f(a, bğŸ˜ˆ}, c)"
  , "f(ağŸ˜ˆ}, b, c)"
  , "f(a, b, cğŸ˜ˆ})"
  , "f(a, b}ğŸ˜ˆ, c)"
  , "f(a}ğŸ˜ˆ, b, c)"
  , "f(a, b, c}ğŸ˜ˆ)"
  , "f(a, ğŸ˜ˆb, c)"
  , "f(ğŸ˜ˆa, b, c)"
  , "f(a, b, ğŸ˜ˆc)"
  , "f(a, }b, c)"
  , "f(}a, b, c)"
  , "f(a, b, }c)"
  , "f(a, ğŸ˜ˆ}b, c)"
  , "f(ğŸ˜ˆ}a, b, c)"
  , "f(a, b, ğŸ˜ˆ}c)"
  , "f(a, }ğŸ˜ˆb, c)"
  , "f(}ğŸ˜ˆa, b, c)"
  , "f(a, b, }ğŸ˜ˆc)"
  , "f(a, ğŸ˜ˆb}, c)"
  , "f(ğŸ˜ˆa}, b, c)"
  , "f(a, b, ğŸ˜ˆc})"
  , "f(a, }bğŸ˜ˆ, c)"
  , "f(}ağŸ˜ˆ, b, c)"
  , "f(a, b, }cğŸ˜ˆ)"
  , "f(, a)"
  , "f(, a, b)"
  , "f(, a, b, c)"
  , "f(a,)"
  , "f(,)"
  , "f()"
  , "f(a)"
  , "f(a,)"
  , "f(a, b)"
  , "f(a, b,)"
  , "f(a, b, c)"
  , "f(a, b, c,)"
  , "let _ = x;"
  , "let x = _;"
  , "let _ = _;"
  , "fun() {}"
  , "(fun() {})"
  , "fun f() {}"
  , "fun(a) {}"
  , "(fun(a) {})"
  , "fun(a, b) {}"
  , "fun(a, b, c) {}"
  , "(fun(a, b) {})"
  , "(fun(a, b, c) {})"
  , "fun f(a) {}"
  , "fun f(a, b) {}"
  , "fun f(a, b, c) {}"
  , "fun(a,) {}"
  , "fun(a, b,) {}"
  , "fun(a, b, c,) {}"
  , "(fun(a,) {})"
  , "(fun(a, b,) {})"
  , "(fun(a, b, c,) {})"
  , "fun f(a,) {}"
  , "fun f(a, b,) {}"
  , "fun f(a, b, c,) {}"
  , "fun() { let x = y; }"
  , "(fun() { let x = y; })"
  , "fun f() { let x = y; }"
  , "fun() {}()"
  , "(fun() {}())"
  , "(fun() {})()"
  , "let f = fun() {};"
  , "let f = fun f() {};"
  , "let f = fun(a) {};"
  , "let f = fun(a, b) {};"
  , "let f = fun(a, b, c) {};"
  , "let f = fun f(a) {};"
  , "let f = fun f(a, b) {};"
  , "let f = fun f(a, b, c) {};"
  , "let f = fun(a,) {};"
  , "let f = fun(a, b,) {};"
  , "let f = fun(a, b, c,) {};"
  , "let f = fun f(a,) {};"
  , "let f = fun f(a, b,) {};"
  , "let f = fun f(a, b, c,) {};"
  , "let f = fun() { let x = y; };"
  , "let f = fun f() { let x = y; };"
  , "let f = fun() {}();"
  , "let f = (fun() {})();"
  , "fun f() {}"
  , "fun f) {}"
  , "fun f( {}"
  , "fun f( { let x = y }"
  , "fun f() }"
  , "fun f() {"
  , "fun) {}"
  , "fun( {}"
  , "fun() }"
  , "fun() {"
  , "fun(a, b let x = y; }"
  , "(fun) {})"
  , "(fun( {})"
  , "(fun() })"
  , "(fun() {)"
  , "(fun(a, b let x = y; })"
  , "fun f(a, b let x = y; }"
  , "fun ğŸ˜ˆ f() {}"
  , "fun fğŸ˜ˆ() {}"
  , "fun f(ğŸ˜ˆ) {}"
  , "fun f() ğŸ˜ˆ {}"
  , "fun f() {ğŸ˜ˆ}"
  , "fun ] f() {}"
  , "fun f]() {}"
  , "fun f(]) {}"
  , "fun f() ] {}"
  , "fun f() {]}"
  , "fun f(,) {}"
  , "return"
  , "return x"
  , "return\nx"
  , "return;"
  , "return;x"
  , "return x;"
  , "return ğŸ˜ˆ x;"
  , "return\nğŸ˜ˆ x;"
  , "return ğŸ˜ˆ\nx;"
  , "return ) x;"
  , "return\n) x;"
  , "return )\nx;"
  , "return ğŸ˜ˆ) x;"
  , "return\nğŸ˜ˆ) x;"
  , "return ğŸ˜ˆ)\nx;"
  , "return )ğŸ˜ˆ x;"
  , "return\n)ğŸ˜ˆ x;"
  , "return )ğŸ˜ˆ\nx;"
  , "break"
  , "break x"
  , "break\nx"
  , "break;"
  , "break;x"
  , "break x;"
  , "loop {}"
  , "loop { let x = y; }"
  , "!x"
  , "+x"
  , "-x"
  , "!x.p"
  , "!x()"
  , "!"
  , "!ğŸ˜ˆx"
  , "!)x"
  , "!ğŸ˜ˆ)x"
  , "!)ğŸ˜ˆx"
  , "!!x"
  , "++x"
  , "--x"
  , "+-x"
  , "-+x"
  , "a + b"
  , "a + b + c"
  , "a - b"
  , "a - b - c"
  , "a * b"
  , "a * b * c"
  , "a / b"
  , "a / b / c"
  , "a % b"
  , "a % b % c"
  , "a == b"
  , "a == b == c"
  , "a != b"
  , "a != b != c"
  , "a < b"
  , "a < b < c"
  , "a <= b"
  , "a <= b <= c"
  , "a > b"
  , "a > b > c"
  , "a >= b"
  , "a >= b >= c"
  , "a + b - c"
  , "a - b + c"
  , "a + b * c"
  , "a * b + c"
  , "a + b / c"
  , "a / b + c"
  , "a * b / c"
  , "a / b * c"
  , "a + b * c + d"
  , "a * b + c * d"
  , "a ^ b + c"
  , "a + b ^ c"
  , "a ^ b * c"
  , "a * b ^ c"
  , "a > b + c"
  , "a + b > c"
  , "a < b + c"
  , "a + b < c"
  , "a >= b + c"
  , "a + b >= c"
  , "a <= b + c"
  , "a + b <= c"
  , "a + b == c"
  , "a == b + c"
  , "a + b != c"
  , "a != b + c"
  , "a =="
  , "== b"
  , "a ğŸ˜ˆ == b"
  , "a == ğŸ˜ˆ b"
  , "a == b ğŸ˜ˆ"
  , "a ) == b"
  , "a == ) b"
  , "a.p + b.q"
  , "!a + !b"
  , "a() + b()"
  , "a + b +"
  , "a + b + c +"
  , "a ğŸ˜ˆ + b + c"
  , "a + ğŸ˜ˆ b + c"
  , "a + b ğŸ˜ˆ + c"
  , "a + b + ğŸ˜ˆ c"
  , "a + b + c ğŸ˜ˆ"
  , "^ b * c ^ d"
  , "a ^ * c ^ d"
  , "a ^ b * ^ d"
  , "a * ^ c * d"
  , "a * b ^ * d"
  , "a ^ b * c ^"
  , "a ğŸ˜ˆ * b + c * d"
  , "a * ğŸ˜ˆ b + c * d"
  , "a * b ğŸ˜ˆ + c * d"
  , "a * b + ğŸ˜ˆ c * d"
  , "a * b + c ğŸ˜ˆ * d"
  , "a * b + c * ğŸ˜ˆ d"
  , "a * b + c * d ğŸ˜ˆ"
  , "a - b + c"
  , "a + -b + c"
  , "if x {} else if y {}"
  , "if x {} else if y {} else {}"
  , "if x {} else if y {} else if z {}"
  , "if x {} else if y {} else if z {} else {}"
  , "if x {} else if {}"
  , "if x {} else ğŸ˜ˆ if y {}"
  , "if x {} else ğŸ˜ˆ if y + z {}"
  , "if x {} else { if y {} }"
  , "a + b * c ^ d"
  , "a * ^ b"
  , "a ^ * b"
  , "a * * b"
  , "a ğŸ˜ˆ * ^ b"
  , "a ğŸ˜ˆ ^ * b"
  , "a ğŸ˜ˆ * * b"
  , "{}"
  , "{p: a}"
  , "{p: a, q: b}"
  , "{,}"
  , "{p: a,}"
  , "{p: a, q: b,}"
  , "{p: a q: b}"
  , "{p: a,, q: b}"
  , "{p: a, q: b,,}"
  , "{p: a q: b,}"
  , "{| o}"
  , "{p: a | o}"
  , "{p: a, | o}"
  , "{p: a, q: b | o}"
  , "{p: a | {q: b}}"
  , "{p: a | {q: b | {}}}"
  , "{p: a | {q: b | o}}"
  , "{: a}"
  , "{p a}"
  , "{p: }"
  , "{: a, q: b}"
  , "{p a, q: b}"
  , "{p: , q: b}"
  , "{p}"
  , "{p, q}"
  , "{p: a, q}"
  , "{p, q: b}"
  , "if {} {}"
  , "if {p: a}.p {}"
  , "{p: a}.p"
  , "{ğŸ˜ˆ p: a}"
  , "{p ğŸ˜ˆ : a}"
  , "{p: ğŸ˜ˆ a}"
  , "{p: a ğŸ˜ˆ}"
  , "{ğŸ˜ˆ}"
  , "a && b"
  , "a && b && c"
  , "a || b || c"
  , "a && b || c"
  , "a || b && c"
  , "a && b && c && d"
  , "a || b && c && d"
  , "a && b || c && d"
  , "a && b && c || d"
  , "a && b || c || d"
  , "a || b && c || d"
  , "a || b || c && d"
  , "a || b || c || d"
  , "case V"
  , "case V()"
  , "case V(a)"
  , "case V(a, b)"
  , "case V(a, b, c)"
  , "case V(,)"
  , "case V(a,)"
  , "case V(a, b,)"
  , "case V(a, b, c,)"
  , "case"
  , "case V"
  , "case V("
  , "case V)"
  , "case ()"
  , "case (a)"
  , "case ğŸ˜ˆ(a)"
  , "let true = x"
  , "let {} = o"
  , "let {a} = o"
  , "let {a, b} = o"
  , "let {a, b, c} = o"
  , "let {,} = o"
  , "let {a,} = o"
  , "let {a, b,} = o"
  , "let {a, b, c,} = o"
  , "let {a: a2} = o"
  , "let {a: a2, b: b2} = o"
  , "let {a: a2, b: b2, c: c2} = o"
  , "let {a: a2, b} = o"
  , "let {a, b: b2} = o"
  , "let {| o} = o"
  , "let {a | o} = o"
  , "let {a, | o} = o"
  , "let {a, b | o} = o"
  , "let {a, b, c | o} = o"
  , "let {a | {b | o}} = o"
  , "let {a | {b | {c | o}}} = o"
  , "let {a | {b | {c | {}}}} = o"
  , "{a: {b: c}}"
  , "{a {}}"
  , "{a true}"
  , "let case V = x"
  , "let case V() = x"
  , "let case V(a) = x"
  , "let case V(a, b) = x"
  , "let case V(a, b, c) = x"
  , "let case V(,) = x"
  , "let case V(a,) = x"
  , "let case V(a, b,) = x"
  , "let case V(a, b, c,) = x"
  , "switch x { y -> {} }"
  , "switch x { y -> {} z -> {} }"
  , "switch x { case Red -> {} case Green -> {} case Blue -> {} }"
  , "switch x {\n\
    \  y -> {}\n\
    \  z -> {}\n\
    \}"
  , "switch x {\n\
    \  case Red -> {}\n\
    \  case Green -> {}\n\
    \  case Blue -> {}\n\
    \}"
  , "switch {} {}"
  , "switch {}"
  , "switch { y -> {} }"
  , "switch x y -> {} }"
  , "switch x { y -> {}"
  , "switch x { -> {} }"
  , "switch x { -> { let a = b } }"
  , "switch x { y {} }"
  , "switch x { y -> } }"
  , "switch x { y -> { }"
  , "switch x { y -> {} let a = b }"
  , "switch x { y -> {} let a = b z -> {} }"
  , "switch x { y -> { let a = b } }"
  , "let x: T = y;"
  , "let x: = y;"
  , "let x T = y;"
  , "(x: T)"
  , "(x:)"
  , "(x T)"
  , "fun f g() {}"
  , "fun f(a: T) {}"
  , "fun f(a: T, b: U) {}"
  , "fun f(a, b: U) {}"
  , "fun f(a: T, b) {}"
  , "fun f(a: T, b: U, c: V) {}"
  , "let f = fun(a: T) {};"
  , "let f = fun(a: T, b: U) {};"
  , "let f = fun(a, b: U) {};"
  , "let f = fun(a: T, b) {};"
  , "let f = fun(a: T, b: U, c: V) {};"
  , "fun f() -> T {}"
  , "fun f() -> {}"
  , "fun f() T {}"
  , "fun f() -> {} {}"
  , "(x: !)"
  , "(x: <> X)"
  , "(x: <T> X)"
  , "(x: <T: A> X)"
  , "(x: <T = A> X)"
  , "(x: <T, U> X)"
  , "(x: <T: A, U: B> X)"
  , "(x: <T = A, U = B> X)"
  , "(x: <T = A, U: B> X)"
  , "(x: <T: A, U = B> X)"
  , "(x: <T, U: B> X)"
  , "(x: <T: A, U> X)"
  , "(x: <T, U = B> X)"
  , "(x: <T = A, U> X)"
  , "(x: <,> X)"
  , "(x: <T,> X)"
  , "(x: <T, U,> X)"
  , "fun f<>() {}"
  , "fun f<T>() {}"
  , "fun f<T: A>() {}"
  , "fun f<T = A>() {}"
  , "fun f<T, U>() {}"
  , "fun f<T: A, U: B>() {}"
  , "fun f<T = A, U = B>() {}"
  , "fun f<T = A, U: B>() {}"
  , "fun f<T: A, U = B>() {}"
  , "fun f<T, U: B>() {}"
  , "fun f<T: A, U>() {}"
  , "fun f<T, U = B>() {}"
  , "fun f<T = A, U>() {}"
  , "fun f<,>() {}"
  , "fun f<T,>() {}"
  , "fun f<T, U,>() {}"
  , "(x: {})"
  , "(x: {a: T})"
  , "(x: {a: T, b: U})"
  , "(x: {,})"
  , "(x: {a: T,})"
  , "(x: {a: T, b: U,})"
  , "(x: {a})"
  , "(x: {a, b})"
  , "(x: {a: T, b})"
  , "(x: {a, b: U})"
  , "(x: {| O})"
  , "(x: {a: T | O})"
  , "(x: {a: T, | O})"
  , "(x: {a: T, b: U | O})"
  , "(x: {a: T, b: U, | O})"
  , "(x: {a: T | {b: U | O}})"
  , "(x: {a: T | {b: U | {}}})"
  , "x\n.Foo"
  , "x;\n.Foo;"
  , "switch x { case VğŸ˜ˆ -> {} }"
  , "switch x { | case V -> {} }"
  , "switch x { |ğŸ˜ˆ -> {} }"
  , "switch x { |ğŸ˜ˆ case V -> {} }"
  , "switch x { case V | ğŸ˜ˆ -> {} }"
  , "switch x { case V | case ğŸ˜ˆ -> {} }"
  , "switch x { case V | case W -> {} }"
  , "switch x { case V | case W | case X -> {} }"
  , "switch x { | case V | case W -> {} }"
  , "switch x { | case V | case W | case X -> {} }"
  , "switch x { case V(y) | case W(y) -> {} }"
  , "switch x { case V(y) | case W(y) | case X(y) -> {} }"
  , "switch x { | case V(y) | case W(y) -> {} }"
  , "switch x { | case V(y) | case W(y) | case X(y) -> {} }"
  , "let case V | case W = x;"
  , "let case V | | case W = x;"
  , "(x: case V)"
  , "(x: case V | case W)"
  , "(x: case V | case W | case X)"
  , "(x: | case V)"
  , "(x: | case V | case W)"
  , "(x: | case V | case W | case X)"
  , "(x: case V(A))"
  , "(x: case V(A) | case W(B))"
  , "(x: case V(A) | case W(B) | case X(C))"
  , "(x: | case V(A))"
  , "(x: | case V(A) | case W(B))"
  , "(x: | case V(A) | case W(B) | case X(C))"
  , "(x: case V | | case W)"
  , "(x: ğŸ˜ˆ case V | case W)"
  , "(x: | ğŸ˜ˆ case V | case W)"
  , "(x: | case V ğŸ˜ˆ | case W)"
  , "(x: | case V | ğŸ˜ˆ case W)"
  , "(x: fun)"
  , "(x: funğŸ˜ˆ)"
  , "(x: fun())"
  , "(x: fun() ->)"
  , "(x: fun() -> A)"
  , "(x: fun(A) -> B)"
  , "(x: fun(A, B) -> C)"
  , "(x: fun(A, B, C) -> D)"
  , "(x: fun(,) -> A)"
  , "(x: fun(A,) -> B)"
  , "(x: fun(A, B,) -> C)"
  , "(x: fun(A, B, C,) -> D)"
  , "(x: fun<>() -> A)"
  , "(x: fun<A>() -> B)"
  , "(x: fun<A, B>() -> C)"
  , "(x: fun<A, B, C>() -> D)"
  , "(x: fun<,>() -> A)"
  , "(x: fun<A,>() -> B)"
  , "(x: fun<A, B,>() -> C)"
  , "(x: fun<A, B, C,>() -> D)"
  , "(x: fun<A, B>(C, D) -> E)"
  , "(x: <A, B> fun<C, D>(E, F) -> G)"
  , "let (x) = y;"
  , "(x: (T));"
  , "(x: <A> (<B> T));"
  , "(x: <A> <B> T);"
  , "/*"
  , "/*/"
  , "/**/"
  , "/* *"
  , "/* **"
  , "/* * /"
  , "/* */"
  , "/* **/"
  , "/* x"
  , "/*/ x"
  , "/**/ x"
  , "/* * x"
  , "/* ** x"
  , "/* * / x"
  , "/* */ x"
  , "/* **/ x"
  , "a + b + c + (d * e)"
  , "f(do{ğŸ˜ˆ;})"
  , "f("
  , "f(a"
  , "f(a,"
  , "f(a, b"
  , "f(a, b,"
  ]

openSnapshotFile :: IO Handle
openSnapshotFile = do
  h <- openFile "test/Brite/Syntax/ParserSpecSnapshot.md" WriteMode
  hPutStrLn h "# ParserSpecSnapshot"
  return h

closeSnapshotFile :: Handle -> IO ()
closeSnapshotFile h = do
  hPutStrLn h ""
  hPutStrLn h (replicate 80 '-')
  hClose h

spec :: Spec
spec = beforeAll openSnapshotFile $ afterAll closeSnapshotFile $ do
  flip mapM_ testData $ \source ->
    it (T.unpack (escape source)) $ \h ->
      let
        (module_, diagnostics) = runDiagnosticWriter (parseModule (tokenize source))
        moduleDebug = Text.Lazy.toStrict (Text.Builder.toLazyText (AST.debugModule (AST.convertModule module_)))
        rebuiltSource = Text.Lazy.toStrict (Text.Builder.toLazyText (CST.moduleSource module_))
      in seq moduleDebug $ do
        hPutStrLn h ""
        hPutStrLn h (replicate 80 '-')
        hPutStrLn h ""
        hPutStrLn h "### Source"
        hPutStrLn h "```ite"
        hPutStrLn h (T.unpack source)
        hPutStrLn h "```"
        hPutStrLn h ""
        hPutStrLn h "### AST"
        hPutStrLn h "```"
        hPutStr h (T.unpack moduleDebug)
        hPutStrLn h "```"
        if null diagnostics then return () else (do
          hPutStrLn h ""
          hPutStrLn h "### Errors"
          flip mapM_ diagnostics (\diagnostic ->
            hPutStrLn h (Text.Lazy.unpack (Text.Builder.toLazyText
              (Text.Builder.fromText "- " <> debugDiagnostic diagnostic)))))
        rebuiltSource `shouldBe` source

escape :: Text -> Text
escape = Text.concatMap
  (\c ->
    case c of
      '\n' -> "\\n"
      '\r' -> "\\r"
      _ -> Text.singleton c)
